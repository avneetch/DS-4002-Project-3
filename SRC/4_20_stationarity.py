# -*- coding: utf-8 -*-
"""4_20_stationarity.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PoQqnKppbd5OMq0_kAhCGsUAXRqg7T5P
"""

# import libraries
import pandas as pd
import numpy as np
import pandas as pd
from datetime import date
import matplotlib.pyplot as plt

# import data
from google.colab import files
uploaded = files.upload()

# read in data
def parse(x):return pd.datetime.strptime(x, "%b %d, %Y")
df = pd.read_csv('real_gas.csv', date_parser=parse)
df

# separate month column into date, month, and year columns
def parse(x):return pd.datetime.strptime(x, "%b %d, %Y")
df = pd.read_csv('real_gas.csv', date_parser=parse)
df['date'] = pd.to_datetime(df['Month'], errors='coerce')
df['month'] = df['date'].dt.month
df['year'] = df['date'].dt.year

df

# https://github.com/jiwidi/time-series-forecasting-with-python/blob/master/time-series-forecasting-tutorial.ipynb

# fix xticks to show dates
# fit polynomial: x^2*b1 + x*b2 + ... + bn
series = df.Real.values
X = [i % 365 for i in range(0, len(series))]
y = series
degree = 100
coef = np.polyfit(X, y, degree)

# create curve
curve = list()
for i in range(len(X)):
    value = coef[-1]
    for d in range(degree):
        value += X[i]**(degree-d) * coef[d]
    curve.append(value)

# plot curve over original data
plt.plot(series, label='Original')
plt.plot(curve, color='red', linewidth=2, label='polynomial model')
plt.legend()
plt.title("Polynomial fit to find seasonality")
plt.show()

from statsmodels.tsa.stattools import adfuller

X = df.Real.values
result = adfuller(X)
print('ADF Statistic: %f' % result[0])
print('p-value: %f' % result[1])
print('Critical Values:')
for key, value in result[4].items():
    print('\t%s: %.3f' % (key, value))

import matplotlib as mpl
import statsmodels as sm
import tensorflow as tf
from statsmodels.tsa import api as smt

# Extra settings
seed = 42
tf.random.set_seed(seed)
np.random.seed(seed)
plt.style.use('bmh')
mpl.rcParams['axes.labelsize'] = 14
mpl.rcParams['xtick.labelsize'] = 12
mpl.rcParams['ytick.labelsize'] = 12
mpl.rcParams['text.color'] = 'k'
print(tf.__version__)

# run Dickey-Fuller test for stationarity
def tsplot(y, lags=None, figsize=(12, 7), syle='bmh'):
    if not isinstance(y, pd.Series):
        y = pd.Series(y)

    with plt.style.context(style='bmh'):
        fig = plt.figure(figsize=(12, 7))
        layout = (3, 2)
        ts_ax = plt.subplot2grid(layout, (0, 0), colspan=2)
        acf_ax = plt.subplot2grid(layout, (1, 0))
        pacf_ax = plt.subplot2grid(layout, (1, 1))
        mean_std_ax = plt.subplot2grid(layout, (2, 0), colspan=2)
        y.plot(ax=ts_ax)
        p_value = sm.tsa.stattools.adfuller(y)[1]
        hypothesis_result = "We reject stationarity" if p_value <= 0.05 else "We can not reject stationarity"
        ts_ax.set_title(
            'Time Series stationary analysis Plots\n Dickey-Fuller: p={0:.5f} Result: {1}'.format(p_value, hypothesis_result))
        smt.graphics.plot_acf(y, lags=lags, ax=acf_ax)
        smt.graphics.plot_pacf(y, lags=lags, ax=pacf_ax)
        plt.tight_layout()

        rolmean = df.Real.rolling(window=12).mean()
        rolstd = df.Real.rolling(window=12).std()

        # Plot rolling statistics:
        orig = plt.plot(df.Real, label='Original')
        mean = plt.plot(rolmean, color='red', label='Rolling Mean')
        std = plt.plot(rolstd, color='black', label='Rolling Std')
        plt.legend(loc='best')
        plt.title('Rolling Mean & Standard Deviation')


tsplot(df.Real, lags=30)

# https://medium.com/pursuitnotes/python-based-oil-gas-price-analysis-1fe5e10a23b0

# plot percent change of gas
import matplotlib.pyplot as plt
pc_gas = df['Real'].pct_change()
pc_gas.hist(bins=100)

# liimit percent changes to 5% changes maximum
import matplotlib.pyplot as plt
plt.hist(pc_gas,bins=100,range=(-0.05,0.05))
plt.show()

pivot_gas = df.pivot_table(values='Real',columns=['year'],aggfunc=np.mean,index=['month'])
pivot_gas.loc[0]=pivot_gas.loc[12,:].shift(1)
pivot_gas.fillna(method='ffill',inplace=True)
pivot_gas = pivot_gas.sort_index()
pivot_gas

# make table of percent change in gas by month
gas_pct = pivot_gas.pct_change()
gas_pct = gas_pct.drop(gas_pct.index[0])
gas_pct

vgas_pct['Rise']=gas_pct[(gas_pct.iloc[:,:]>0)].count(axis=1)/(2023-1979)
gas_pct['Decline']=gas_pct[(gas_pct.iloc[:,:]<0)].count(axis=1)/(2023-1979)
gas_pct[['Rise','Decline']]